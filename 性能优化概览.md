# 前端性能优化介绍

## web 性能指标

### RAIL 性能模型

> Response-Animation-Idle-Load
>
> 参考链接: https://zhuanlan.zhihu.com/p/159276455 https://web.dev/rail/
>
> 性能优化: https://www.cnblogs.com/xiaohuochai/p/9178390.html

1. R(Response) 响应

- 指标:指应该尽可能快速的响应用户,应该在100ms以内响应用户输入

- 网站性能对于响应方面的要求是，在用户感知延迟之前接收到操作的反馈。比如用户进行了文本输入、按钮
  单击、表单切换及启动动画等操作后,必须在100ms内收到反馈，如果超过100ms的时间窗口,用户就会
  感知延迟。
- 看似很基本的用户操作背后，可能会隐藏着复杂的业务逻辑处理及网络请求与数据计算。对此我们应当谨
  慎,将较大开销的工作放在后台异步执行，而即便后台处理要数百毫秒才能完成的操作，也应当给用户提供
  及时的阶段性反馈。

- 以下是用户对性能延迟的感知：
  - 延迟时间: 用户感知
  - 0-16ms: 很流畅
  - 0-100ms: 基本流畅
  - 100-1000ms: 感觉到网站上有一些加载任务
  - 1000ms or more: 失去耐心了
  - 10000ms or more: 直接离开，不会再访问了

2. Animation 动画

- 产生每一帧的时间不要超过10ms，为了保证浏览器60帧，每一帧的时间在16ms左右，但浏览器需要用6ms来渲染每一帧。
- 旨在视觉上的平滑。用户对帧率变化感知很敏感。

3. Idle 最大化空闲时间

- 最大化空闲时间，以增大50ms内响应用户输入的几率

4. Load 响应

- 传输内容到页面可交互的时间不超过5秒
- 如果页面加载比较慢，用户的交点可能会离开。加载很快的页面，用户平均停留时间会变长，跳出率会更低，也就有更高的广告查看率

RAIL是一个旅程，为了提升用户在网站的交互体验而不断探索。你需要去理解用户如何感知你的站点，这样才能设置最佳的性能目标

- 聚焦用户
- 100ms内响应用户的输入
- 10ms内产生1帧，在滚动或者动画执行时
- 最大化主线程的空闲时间
- 5s内让网页变得可交互

### Web Vitals

> 是谷歌针对网页加载速度和体验所提出的一套指标，这套指标用于测试网页的加载速度及用户体验等等；谷歌基于这套指标不仅设计了多套测试工具，还针对各种指标提出了相应的优化方法，具有很高的实用价值；

1. `LCP` 加载体验

   - 概念: `LCP`（`Largest Contentful Paint`），即**最大内容渲染**，指的是视窗（`viewport`）内所有可见元素中尺寸最大的文本块或图像所需的渲染时间；

   - 指标作用: 用来弄清用户所看到的页面主体内容何时被渲染出来，之前也有相应的指标用于相似的目的，但是实际上存在很多的不足

     - `load`和`DOMContentLoaded`事件只是反应了代码层面的加载时间结点，而非真实用户所关注的屏幕页面渲染效果，因此很不准确；
     - 而`FCP`指标也只是关注了最初始的渲染效果，和用户关心的页面整体效果也相差甚远；
     - 后面提出用于关注初始渲染状态之后的加载效果的指标——`FMP`（`First Meaningful Paint`）和`SI`（`Speed Index`），经实践证明效果不太行，经常出错，而且这两个指标计算很复杂也很难去解释；

   - 如何寻找最大元素: 由于`LCP`关心的只是文本块及图像，因此寻找的元素结点限定为：

     - `img`元素
     - `svg`元素中的`image`元素
     - 带`poster`属性的`video`元素
     - 用`url()`方法加载**背景图**的元素
     - 包含文本节点或其它内联文本节点的**块级**元素

     限定了元素范围后，接下来就是从这些元素中找出尺寸最大的元素了，那么**如何计算这些元素结点的大小**？这里的尺寸大小计算遵循以下原则：

     - 尺寸大小实际上以渲染完成后的大小为准
     - 尺寸不包括`padding`，`border`和`margin`，可以理解为`content-box`的大小

     由于图片资源需要异步加载完成后才会进行渲染以及`js`代码修改`DOM`结构和属性等因素的存在，因此这个最大渲染元素可能会发生改变，所以最大渲染元素的检测需要首屏渲染完成后才能最终确认；

2. FID 交互性

   - 概念: `FID`（`First Input Delay`），即**第一次输入事件延迟**，指的是用户第一次交互事件触发到主线程接收事件然后反应之间的时间；

   - 指标作用: 

     1. 这个指标主要是从交互响应层面来**量化**用户对页面的第一印象；

     2. 页面加载阶段，资源的处理任务最重，也最容易产生输入延迟，关注此指标利于优化用户交互体验；
     3. 一般通过 Code Splitting 等方式减少页面加载阶段 JS 的加载，解析和执行时间

3. CLS 页面内容的视觉稳定性

   - 概念: `CLS`（`Cumulative Layout Shift`），即**累积布局偏移**，指的是首屏页面渲染过程中所有元素结点相对原始位置所发生的位置偏移累积量；
   - 指标作用: 该指标主要是为了量化渲染过程中的视觉稳定性（`visual stability`）；因为渲染过程或者交互过程中发生的非用户期待的视觉改变行为会影响用户的使用满意度，而布局偏移就是其中一种很常见的现象，经常出现在：
     - `img/video`等媒体元素未指定尺寸，当资源加载完成后渲染尺寸发生改变，通常表现为突然地闪变，以及影响周围元素的位置变化
     - 插入一些`DOM`结点，导致用户原本关注的区域突然偏移
   - 计算原理：score = 距离系数 * 影响分数
     - 分数越低越好，表示偏移值较低
     - 例： 元素向下移动了视口高度的 1/3 ， 所以距离系数是 0.33， 元素在其起始位置和移动后的位置 所占的面积占视口总面积的 2/3，则影响分数为 0.66，布局偏移得分为 0.33 * 0.66 = 0.2178

### 其他特性

- 长任务

  > 主线程上 js 执行时间大于 50ms 的任务,称之为长任务

  - `TBT`（`Total Blocking Time`）总阻塞时间
    
    - 阻塞时间是指主线程上,大于50ms 任务的时间差,如一个长任务运行时间200ms,则阻塞时间是 150ms
    - 主线程上运行任务花费的所有长任务的阻塞时间之和, 0-300ms为快速,300-600ms为中等,超过600ms为慢
    
  - `TTFB`（`Time to First Byte`）用户浏览器从开始加载网页内容到接收到第一个字节的网页内容之间的耗时，该指标主要侧重于网页加载体验；
  
  - `FCP`（`First Contentful Paint`）从开始加载网页内容到第一个文本块或者图像渲染完成之间的耗时，该指标主要侧重于网页加载体验；
  
  - `TTI`（`Time to Interactive`）内容是否可用
  
    从开始加载网页内容到开始有足够快的用户交互反应速度时之间的耗时，该指标主要侧重于网页加载体验；一般这个“有足够快的用户交互反应速度”指的就是`FCP`后长任务（`long task`，大于`50ms`的主线程任务）都执行完毕后，实际上就是主线程开始空闲，那自然就对用户交互就有很快的反应速度；可以看下官方文档的`TTI`计算步骤图
  
    `算法实现`: 
  
    1. 首次进行内容绘制（FCP）
    2. 沿时间轴正向搜索时长至少为5秒的安静窗口，其中，安静窗口的定义为：没有长任务且不超过两个正在处理的 GET 网络请求
    3. 沿时间轴反向搜索安静窗口之前的最后一个长任务，如果没有找到长任务，则在 FCP 步骤停止执行
    4. TTI 是安静窗口之前最后一个长任务的结束时间，如果没有找到长任务，则与 FCP 值相同
  
  - SI （Speed Index）页面可视区域加载速度
  
    - 衡量页面可视区域加载速度，帮助检测页面的加载体验差异

## web 性能测试

### Lighthouse 灯塔

> - 在谷歌的 开发者工具中可以直接使用
> - 使用npm包 https://github.com/GoogleChrome/lighthouse
> - node 模块化

1. 使用方法:
   - 在终端输入命令， $ lighthouse https://www.cnblogs.com/  便会生成一个HTML页面,在浏览器中打开查看
   - 使用谷歌浏览器控制台生成
2. 分数占比不同:
   - FCP 10%, SI 10%, LCP 25%, TTI 10%, TBT 30%, CLS 15%
3. 常见优化建议:
   - 移出阻塞渲染的资源
   - 预链接所要请求的源
     - 提前建立与所要访问资源之间的网络链接,加快域名解析速度
     - 预链接 <link rel='preconnect'>
     - DNS预解析 <link rel='dns-prefetch'>
   - 降低服务器端响应时间
     - 升级服务器硬件以拥有更多的内存或CPU
     - 优化服务器应用逻辑
     - node服务器转发层优化
   - 适当调整图片大小
     - 首页加载的图片可以使用小图或压缩后的图片, 等待大图或高清图异步加载完成以后再替换
   - 移除未使用的CSS

### 浏览器插件 Web Vitals

> 谷歌应用商店下载,能看到的就是简单的 加载性,交互性,页面内容的视觉稳定性 三个指标

### 使用 Web-vitals库

- https://github.com/GoogleChrome/web-vitals js 包

### 浏览器调试

shift + esc 打开浏览器的任务管理器,查看页面的资源占用情况

### Network 网络分析

> 浏览器控制台里面的网络那一部分,主要查看请求资源类型,时间等信息

### WebPageTest 

> 本地部署 1. 安装 Docker  2. 拉取镜像 3. 运行实例

- 主要是提供了不同的环境,不同的设备,不同的节点
- 可以测试全球各地不同的服务器节点,调测试的配置,使用 Vitals, 灯塔, 等配置进行配置
- 免费版不太好用,测试完以后也会得到测试报告,得到的结果和灯塔类似

### performance

> 浏览器 的性能测试面板, 当前运行状况进行录制

## 前端页面声明周期

性能问题呈现给用户的感受往往是简单而直接的:加载资源缓慢、运行过程卡顿或响应交互迟缓等,当把这些问题呈现到前端工程师面前时，却是另-种系统级别复杂的图景, 从域名解析、TCP建立连接到HTTP的请求与响应，以及从资源请求、文件解析到关键渲染路径等,每一个环节都有可能因为设计不当、考虑不周、运行出错而产生性能不佳的体验。作为前端工程师，为了能在遇到性能问题时快速而准确地定位问题所在,并设计可行的优化方案,熟悉前端页面的生命周期是- -堂必修课。

### 进程与线程

1. 简单来说，进程就是一个程序运行的实例，操作系统会为进程创建独立的内存，用来存放运行所需的代码和数据;而线程是进程的组成部分,每个进程至少有一个主线程及可能的若干子线程,这些线程由所属的进程进行启动和管理。由于多个线程可以共享操作系统为其所属的同-个进程所分配的资源,所以多线程的并行处理能有效提高程序的运行效率。

   > 一个应用就是一个进程,占据独立的内存,线程是最小执行单元, 一个cpu 一个核心 同一之间只能执行一个线程里面的任务
   >
   > 单核cpu 也可以执行多任务 原因就是时间片切换

2. 浏览器的模型是多进程模型, 因为线程之间资源是共享的, 一个线程崩溃,可能会导致自己所处的进程崩溃

3. 

### 输入URL  发生了什么?

1. 浏览器接收到URL,到网络请求线程的开启
2. 一个完整的HTTP请求发出
3. 服务器接收到请求,并转到具体的处理后台
4. 前后台之间的HTTP交互和涉及的缓存机制
5. 浏览器收到数据包后的关键渲染路径
6. JS引擎的解析过程

## 基于生命周期的优化方案

- 从发出请求到收到响应的优化,如DNS查询,HTTP长链接,HTTP压缩,HTTP缓存等
  - 什么情况下需要让用户有感知?
- 关键渲染路径优化,比如是否存在不必要的重绘和回流
- 加载过程的优化,比如延迟加载,是否有不需要在首屏展示的非关键信息,占用了页面加载的时间
- 资源优化,比如图片,视频等不同的格式类型会有不同的使用场景,在使用的过程中是否恰当
- 构建优化,比如压缩合并,基于webpack构建优化方案

## 参考连接 

https://mp.weixin.qq.com/s/E61cNsDPLvD_n2sqmNCXYA